---
title: 聊明白机器学习 | 三. 误差都是哪来的？　       
date: 2019-05-26 20:20:24
tags: Basic
toc: true
thumbnail: http://cdn.1ouo1.com/zc9cd.jpg
meta: true
mathjax: true
---

## 前言干话

换工作的过渡期，真一点不比原来工作时间轻松啊。有太多上家的牵挂（当然最终人家可能不这么看你），和默默给下家准备的惊喜都需要十分用心。

最近也开始重启减重计划了，最近两天直降 5 斤。我基数比较大，方法也比较笨，无非少吃糖脂多流汗。一开始可能会有反复时间，管住嘴憋得很难受，结果发现体重竟然还纹丝不动。但所幸稍稍挺住这个时间会比较快过去，接下来会进入对食物的低欲望周期，就是吃点啥都无所谓了，此时就可以正常上你的减脂食谱了。同时锻炼后的身体肌肉此时会不断给你带来良好的正向反馈，美滋滋。夏天结束后，咱们再来看成果。
最近还弄了个方便大家听逼哥 2019 跨年音乐的小功能，点击左面板上的 ![](http://cdn.1ouo1.com/idurr.png) 即可使用。

下面进入正文，今天细说一下回归模型中的误差问题。
<!-- more -->

## 误差的两个来源

上一篇里面我们说到了训练时使用不同的模型（Model）中，可能会出现不同的误差情况。甚至有些时候越复杂的模型可能带来越差的表现。

![](http://cdn.1ouo1.com/q8ibx.png)

比如上图，横坐标是模型的次方数，纵坐标是误差值。后面模型复杂到四次方、五次方时，错误率就起飞了。

今天我们就来细看一下这个误差。开门见山来说，这个误差其实有两个来源，分别是：偏离值（Bias）和方差（Variance）。我们后面就想办法针对这两方面误差，使用恰当的办法来提升模型的表现。

![](http://cdn.1ouo1.com/4chhu.png)

回到上一次宝可梦的例子里。我们算一直杰尼龟进化后的战斗值（CP），真实的算法 $\hat{f}$ 其实只有宝可梦的制作公司（Niantic）知道，我们平民百姓只能根据训练数据来找到最为接近它的方法 ${f}*$，相当于找这个真实算法的估测值。

这件事情就好像我们确立了一个靶子，理想靶心的位置就是 $\hat{f}$，我们最终得到的平民答案 ${f}*$ 总是和它中间有段距离，这个距离可能来自偏离值（Bias），也可能来自方差（Variance）。

### 数学上的道理

概率论里我们也遇到过类似的场景。假设有变量 $x$，它的平均值是 $μ$，方差是 $\sigma^2$（这些拉丁字母的数学含义忘了就忘了，别紧张，领会意思即可）。

如果我们要估测平均值 $\mu$，正常做法就是我们能去抽样 N 个点，求个平均值即可。但我们心里清楚，这个算得的平均值跟真实的 $\mu$ 不一样，会有误差（抽样嘛）。即便我们做了很多次实验得到很多个平均值 $m_1$、$m_2$、$m_3$...它们都很难正好等于 $\mu$。但我们知道如果要说平均值 $m$ 的期望（Expect）值 $E(m)$，那它确实是正好等于 $\mu$ 的，这应该好理解。

特别地，在上面概率论这个场景里，我们用 $m$ 去估测平均值时候，因为我们明确知道「靶心」要瞄准的值为 $\mu$，故此时这是个没有偏离值（Bias）的情况，后面会提到不一样的情况。 

做概率论例子估测的实操时，我们将取很多样本值（特别注意，下图素材中的 $x^2$ 代表第二组 $x$ 数据，如果具体表示第二组 $x$ 中的第一、第二个值，则表示为 $x^2_1$、$x^2_2$，以后也会有类似编号写在上标位置的情况，不要误会成次方了），接着我们算出平均值 $m$，$m$ 的期望值是 $\mu$，且它没有偏离值（Unbiased）。则实际样本就是如图均匀散落在 $\mu$ 周围的，但很难直接等于 $\mu$。

![](http://cdn.1ouo1.com/snc4z.png)

那么会散落得多分散呢？这就取决于估测平均值 $m$ 的方差（Variance）了。方差等式如下图，这是概率论知识，了解意思即可。**这个方差值越大，样本越分散，反之越集中**。方差的大小，跟每次抽样我们「拿多少样本作为一份」有关。道理很简单：我们每次抽样时候多拿一些样本数据来算平均，自然它就更精准，每次算得的结果 $m$ 就更接近真实平均值 $\mu$。

![](http://cdn.1ouo1.com/qzbet.png)

这个方差我们当然也要估测。我们一般会用下图中这个带 $s^2$ 的式子来估测方差 $\sigma^2/N$ 。但注意，此时的估测值就是有偏离的了，在数学上 $s^2$ 会比 $\sigma^2$ 稍小，注意有个 $(N-1)/N$。所以从图上的串串来看，发现蓝色的估测点虽然也是落在真正的方差周围，但比它小的点更多。并且当我们扩大每次的抽样量 N，得到的估测点就会更集中分布在真正的方差周围，即上面提到的那个道理。

![](http://cdn.1ouo1.com/t6uza.png)

### 这俩问题的综述

所以回归到靶子的例子来更形象地总结一下这两方面问题。

我们要估测靶心目标，拿了很多样本，我们辛辛苦苦找了每一组样本对应的 $f^*$，把这些 $f^*$ 取平均，得到 $\bar{f}$，它就是 $f^*$ 的期望值了，换句话说就是我们认为的靶心。那么这个**靶心（我们每次心里想瞄准的地方） $\bar{f}$ 和真实的靶心 $\hat{f}$ 之间就存在偏差，这个偏差就叫偏离值（Bias）**。

此外，每次我们瞄准了，但手不听使唤容易打不准，故每次「射击」都还存在一个**瞄准位置和实际射中位置的偏差，这个偏差就叫方差（Variance）**。下图中对应了两个偏差出现的场景。我们最终追求的是左上角的情况，即没有偏离值，且方差最小。

![](http://cdn.1ouo1.com/x67em.png)

## 问题与模型的关系

前面说到，为了更精确地估测真正的方法 $\hat{f}$，我们需要通过多次试验来找到多个 $f^*$，这里为了节约篇幅，不具体讲某一次的试验，而是我们通过更高的视角来看这件「不断靠近真实 $\hat{f}$ 的」事情。

我们进行多次试验的过程中，每一次都会采集不同的样本，每一次也都会产生出不同的 $f^*$。科幻点讲，这就很像我们在很多个平行宇宙（Parallel Universes）里为了同一个目标（正确估测进化后战斗值），分别抓 10 只不同的宝可梦，分别做一次试验的感觉。如下图。

![](http://cdn.1ouo1.com/co6cg.png)

很自然，对于每个「平行宇宙」，我们给不同的数据，找出来的 $f^*$ 肯定不一样嘛。比如 123 号平行宇宙里，我们找出来的 $f^*$ 如下图左边；而 345 号平行宇宙里，我们找出来的 $f^*$ 如下图右边。

![](http://cdn.1ouo1.com/nxtcw.png)

### 平行宇宙里的方差

每个平行宇宙的一次实验就像是我们对着靶开出不同的每一枪一样。

假如有 100 个平行宇宙（好富有的感觉），那就像是开出了 100 枪。我们把它们每次做出的 $f^*$ 分别画出图如下。

![](http://cdn.1ouo1.com/c7pja.png)

注意看，图里实际上画了三种不同复杂程度的模型（Model）分别操作是什么情况。其中五次方的复杂模型看起来挺恐怖的，好像这里面中每一个值都会被触发一样。

![](http://cdn.1ouo1.com/3mzyg.png)

所以从图里来看，**模型如果比较简单，得到的结果反倒是集中的，即方差（Variance）小**，简单来理解就是这个模型的输出结果受样本数据的影响比较小（试想一下极限情况：最简单的模型即一条常量的直线 $f(x)=c$，此时方差为 0，它不受样本的任何影响，就一根线，无比集中）；反之，模型如果比较复杂，散布就会很大很开，每条线的差别都很大，即方差（Variance）很大。

### 平行宇宙里的偏离值

至于偏离值（Bias），我们前面说过，指的是我们已经有了多个 $f^*$，得到期望值 $\bar{f}$ 后，这个 $\bar{f}$ 与真实的方法 $\hat{f}$ 之间的距离，它就是偏离值（Bias）。

为了感受偏离值和不同模型之间的关联关系，我们假定下图里的黑线是我们孜孜追求的真实方法 $\hat{f}$ 的样子。那么意味着宝可梦的进化后战斗值就是从这个黑线上算来的，也即我们每次做实验抽的 10 个点，都是拿的这黑线上的某 10 个点。

![](http://cdn.1ouo1.com/omn4z.png)

那么接下来我们再来图里看，黑线是真实方法，红线是我们通过 5000（为了突出效果我们把试验次数提高到 5000 ）次试验每次得到的 $f^*$，蓝线是我们拿所有红线求均值得到的 $\bar{f}$。

同理，为了感受模型复杂度与偏离值的关系，上面三个图分别是一次方模型、三次方模型、五次方模型分别操作得到的图。

我们会发现，虽然越高次越复杂得到的 $f^*$ 画图看起来很可怕，都铺满了，每个 $f^*$ 相差很多，但平均起来，反而是最接近真实方法 $\hat{f}$ 的，即：**越复杂的模型，会拿到越小的偏离值（Bias）。**

![](http://cdn.1ouo1.com/lj8gl.png)

这件事可以这样理解：越高次方越复杂的模型，他所覆盖的可能性空间就越大，包含你理想方法的可能性也就越大，你只要找出来，它就能给你偏差很小的结果。那么**反之，越简单的模型，会有越小的方差（Variance），有越大的偏离值（Bias）**。

### 一个平衡问题

![](http://cdn.1ouo1.com/dl3vc.png)

所以我们可以把模型选择和误差表现的关系作图如上。从左到右，随着模型越来越复杂，偏离值（Bias）下降，方差（Variance）上升。

于是乎，这又回到了一个平衡问题了。图中的蓝线是一个综合总体误差水平，我们要综合考虑偏离值和方差，找一个使得综合总体误差最小的模型。

特别地，我们把偏离值（Bias）大的错误情况叫做「欠拟合（Underfitting）」，把方差（Variance）大的错误情况叫做「过拟合（Overfitting）」，过拟合也有时被称作「过度拟合」。

## 具体实操

当我们拿到一个待优化的模型，我们如何去分辨这个模型的问题主要在偏离值（Bias）上还是在方差（Variance）上呢？

### 偏离值（Bias）大咋办

![](http://cdn.1ouo1.com/rxqur.png)

我们可以去看实验中的现象。如果你这个模型连「训练用的真实样本数据」都无法很好地吻合上，那说明模型离正确的模型还有很大的距离，即偏离值（Bias）很大，你欠拟合（Underfitting）了。

如果偏离值（Bias）大，说明你追求的真实方法 $\hat{f}$ 压根不在你的模型覆盖圈里，这时就需要重新设计这个模型了。比如找更多的特性来扩充丰富模型（宝可梦的血量、体重啊之类），或者让模型更复杂（选用更多次方的式子之类）。特别注意，这时候我们去找更多的训练数据是没用的。

### 方差（Variance）大咋办

反过来，如果你这个模型能很好地吻合样本数据，但是一跑测试数据就表现不好，则是方差（Variance）很大，你过度拟合（Overfitting）了。

![](http://cdn.1ouo1.com/n2252.png)

如果方差（Variance）大，一个很有效的办法就是：去更多地搜集训练数据！比如上图，如果每次我们能从 10 个样例数据扩展到 100 个样例数据来训练，得到的结果会集中很多。一句话就是：**这时候，数据多真的是可以为所欲为的！**

当然了，想想也知道：总是要更多数据往往不太现实（甚至让你可能容易被炒鱿鱼），此时，聪明的我们还留有两招可用。

第一招，是按照你的理解，去自己制作更多数据用于训练。比如做图像识别训练，我们把图像转个角度，就得到新的图片（因为你训练的机器回头也得能识别不同角度的东西嘛）；再比如声音识别训练，我们用变声器处理一下已有的声音，得到不同性别的声音...或者添加背景噪音，去让模型[健壮性](https://zh.wikipedia.org/wiki/%E9%B2%81%E6%A3%92%E6%80%A7)更强；再比如多语种语义识别训练，我们把已有语义批量翻译成其他语种...

![](http://cdn.1ouo1.com/jgwmz.png)

第二招，是我们在模型里添加一项调整（Regularization）项，这个跟我们[前一篇](http://talk2.it/post/regression#%E6%83%B3%E5%8A%9E%E6%B3%95%E8%B0%83%E6%95%B4%E4%B8%80%E4%B8%8B)里增加调整项的思路异曲同工。具体做法是，我们在 L 函数（损失函数，Loss Function）中增加一项，来约束参与的参数，让他们尽可能小，以使得得到的曲线尽可能平滑。当然，我们同样还需要一个 $\lambda$ 值来控制我们多大程度地考虑平滑度问题。平滑后效果如下图。

![](http://cdn.1ouo1.com/a71fu.png)

但要注意的是，第二招这个操作可能会使得偏离值（Bias）有所增加。因为你过滤掉了一些不那么平滑度的函数，这些函数里是可能包含有更好的 $f$ 的。

### 选模型时候要小心

我们得到多个 $f$ 之后，开始平衡偏离值（Bias）和方差（Variance），挑选使得测试误差（Testing error）最小的那个。

这时要特别注意，对于通过训练数据训练出来的模型们，这时你用你拥有的测试数据（Testing data）来挑选出使得测试数据误差最小的 $f$，你接着兴冲冲地拿这个 $f$ 去公开投放到真实的测试数据当中，它的表现很经常不如你在使用测试数据时的表现。

因为你有限的测试数据们的分布，是极有可能跟大量真实数据的分布形态存在偏差。这句话的描述可能不够到位，但产生的结果就是：当两套数据来测一个跟真实方法有偏差的 $f$ 时，两套数据的误差表现很可能是不一样的。所以你通过你的测试数据调出来的方法嘛，可能只在你自己的测试数据里表现是最好的...

![](http://cdn.1ouo1.com/dxmce.png)

总之在实操时候，直接通过公共的有限测试数据来挑 $f$ 是不可取的。因为真实在「生产环境」里考验它的，那些你没见过的数据（Private Set）可能会让它表现差很多。

### 推荐的做法

这时候推荐的做法是把我们已有的训练数据（Training Data）分成两份。用第一份作为训练组（Training Set）来训练你的模型；再用另一份作为验证组（Validation Set）来选出错误最小，表现最佳的。

如果你觉得这样训练组的数据太少了，那么可以在第二份验证组数据选出了最好模型之后，再用整个训练数据一起重新训练这个最佳模型一次。

![](http://cdn.1ouo1.com/par9e.png)

此时，在公开的测试数据上去测这个模型，你会发现错误表现比训练时候要更大，但这，才能真实反映在未来公开的，未知的测试数据（Private Set）中你这个模型的错误表现。

尤其需要**注意避免**的是，你在公开的测试数据测完发现错误率比训练时候高的时候，相信你会很有冲动再回头去调整一下模型，企图让模型在公开测试数据上也表现得更好。这是不可取的（当然你可能经常控制不住自己）！因为这种操作相当于你又加入了公开测试数据集的这些有限数据的偏差影响（跟前面那个不够到位的描述是一个道理）。

总之，公开的测试数据集上的表现都是「浮云」，真正你需要在乎的是真实投放出去后，在未知的测试数据（Private Testing Set）中的表现。

![](http://cdn.1ouo1.com/wlse6.png)

当然，你如果更考究的话，可以做得更细。比如把训练数据集分成三等分，并且采用不同的切分方案去多次三等分这些数据。每次拆分，里面的两份拿出来作为训练组（Training），剩下一份拿来作为验证组（Validation）。每次拆分完，都把模型丢进去给训练组训练，完后给验证组算错误值。有几套拆分方案就这样操作几次。然后看每个模型的多次验证组错误的平均值，取这个平均错误值最小的模型，作为你的最佳模型。然后拿着他，再经过全体训练数据训练一次后，就可以拿公开测试数据集（Public Testing Set）跑来看一眼了，误差没有特别不可接受的话，就别动人家了。

总之，原则上，不要太在意这个公开测试数据集（Public Testing Set）上的错误结果，少去根据这个结果来调整模型。往往这样按规矩办事，后面在真实未知数据集（Private Testing Set）上得到的误差才会跟目前实测的误差相差较小。

好啦，今天先到这，下一篇我们要细说一下梯度下降（Gradient Descent）的操作了，越来越实战，加油。
